#include <stdio.h>

//itoa: nをs中の文字に変換する

void itoa(int n, char s[])
{
    int i, sign;

    if ((sign = n) < 0)//符号を記録する
        n = -n;//nを正にする

    i = 0;
    do
    {//数字を逆順に生成する
        /* code */
        s[i++] = n % 10 + '0'; //次の桁をとってくる
    } while ((n /= 10) > 0);//それを削除する

    if (sign < 0)
        s[i++] = '-';
    s[i] = '\0';
    reverse(s);
}

/*
do-while文は、必ず一度は実行されるループ構文です。

🔁 do-whileの基本構文
c
コピーする
編集する
do {
    // 繰り返す処理
} while (条件);
whileループと違って、条件の判定が最後にあるため、

最低でも1回は必ずループ本体が実行されるのが特徴です。

🧠 今回のコードでの do-while の意味
c
コピーする
編集する
i = 0;
do {
    s[i++] = n % 10 + '0'; // 1の位から1文字ずつ文字に変換
} while ((n /= 10) > 0);   // 次の桁へ（nを10で割る）→ 0になるまで続ける
これは、数値 n を 1の位から順に文字に変換して、文字配列 s に格納する処理です。

例）n = 123 の場合：
n % 10 → 3 を文字に変換 → '3' を s[0] に格納

n /= 10 → 12

n % 10 → 2 → '2' を s[1] に格納

n /= 10 → 1

n % 10 → 1 → '1' を s[2] に格納

n /= 10 → 0 → ループ終了

文字列には 3, 2, 1 の順に入っているので、最後に reverse(s) して 123 になります。

✅ なぜ do-while が必要か？
もし n = 0 の場合：

while だけなら、最初から条件 n > 0 が false → 1回も実行されない

でも itoa(0, s) は "0" を出力するべき！

つまり do-while で 1回だけでも処理を保証することで、n = 0 のときも "0" を正しく出力できます。

📌 まとめ
特徴	内容
実行順	まず実行 → 条件判定
最低実行回数	1回保証
利用シーン	1回は必ず処理したいとき（例：itoa(0) など）
*/